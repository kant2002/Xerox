// BNCG1.bcpl - BCPL Compiler -- Nova Code Generator, Impure stream processor// Copyright Xerox Corporation 1980//   Last modified on Wed 01 Nov 72 0141.31 by  jec.get "bncgx"let ScanImpures() be [      let Op = nil    ///*DCS* More complex lookup    let N, Nameptr = nil, nil    let v = vec NAMELENGTH    if PassTwo do WB(llabelt) Next:    Op = Readop()    if Op eq ENDSTATIC do     [		return      ]    N = ReadL()    ///*DCS* new    Nameptr = LookForSym(N)    Unpackstring(Nameptr, v)    let val, valtype, ext, com = 0, 0, 0, 0    switchon Op into     [	default:	CGreport(-1)	case ZEXT:	    com = 1	case EXT:	    goto Out	case ZINT:	    com = 1	case INT:	    goto Val	case ZLOC:	    com = 1	case LOC:	    ext = 1	    goto Val     ]Val:    Op = Readop()    val = Nval(ReadN())    vlabelt = vlabelt + 1    switchon Op into     [	case STATIC:	    valtype = 1	    goto Out	case ENTRY:	    valtype = 2	    goto Out	case LENTRY:	    valtype = 3	    goto Out	default:	CGreport(-1)      ]Out:    let t = (valtype lshift 5) + (com lshift 4) + ext    let n = vec NAMELENGTH/2    let k = STRval(v, n)    if PassTwo do WB(t)    if PassTwo do WB(val)    for i = 0 to k do if PassTwo do WB(n!i)    unless SWCode goto Next    WW(com eq 0 ? $*s, $z)    test valtype eq 0 then WriteS("EXT")    or test ext eq 0 then WriteS("INT")    or			  WriteS("LOC")    WW($*t)    WriteO(vlabelt)    WW($*t)    ///*DCS* changed    WriteName(N)    if valtype ne 0 do         [ WW($*t)    ///*DCS* changed	   if Length(Nameptr) ls 8 do WW($*t)	   test valtype eq 1 then WriteOct(val)	   or [ WriteS("LAB"); WriteOct(eaddrvec!val) ]	  ]    WW($*n)    goto Next  ]